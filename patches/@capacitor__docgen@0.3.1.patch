diff --git a/dist/output.js b/dist/output.js
index 5f8cc8a222e58be00875ca0c8e6b3335c45ff87d..260a93d25a1971155000577e254f8624039dfa63 100644
--- a/dist/output.js
+++ b/dist/output.js
@@ -4,15 +4,11 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.outputJson = exports.replaceMarkdownPlaceholders = exports.outputReadme = void 0;
-const fs_1 = __importDefault(require("fs"));
 const path_1 = __importDefault(require("path"));
 const formatting_1 = require("./formatting");
-const util_1 = require("util");
+const promises_1 = require("fs/promises");
 const markdown_1 = require("./markdown");
 const parse_1 = require("./parse");
-const readFile = util_1.promisify(fs_1.default.readFile);
-const writeFile = util_1.promisify(fs_1.default.writeFile);
-const mkdir = util_1.promisify(fs_1.default.mkdir);
 async function outputReadme(readmeFilePath, data) {
     if (typeof readmeFilePath !== 'string') {
         throw new Error(`Missing readme file path`);
@@ -22,13 +18,13 @@ async function outputReadme(readmeFilePath, data) {
     }
     let content;
     try {
-        content = await readFile(readmeFilePath, 'utf8');
+        content = await promises_1.readFile(readmeFilePath, 'utf8');
     }
     catch (e) {
         throw new Error(`Unable to read: "${readmeFilePath}".\n\nIf this is the correct path, please create the file first, then run again.`);
     }
     content = replaceMarkdownPlaceholders(content, data);
-    await writeFile(readmeFilePath, content);
+    await promises_1.writeFile(readmeFilePath, content);
 }
 exports.outputReadme = outputReadme;
 function replaceMarkdownPlaceholders(content, data) {
@@ -38,7 +34,8 @@ function replaceMarkdownPlaceholders(content, data) {
     if (data == null || data.api == null) {
         throw new Error(`Missing data`);
     }
-    data = JSON.parse(JSON.stringify(data));
+    // OPTIMIZATION: Removed expensive JSON clone (data = JSON.parse(JSON.stringify(data)))
+    // We treat 'data' as read-only or create new objects where needed.
     content = replaceMarkdownDocsIndex(content, data);
     content = replaceMarkdownDocsConfig(content, data);
     content = replaceMarkdownDocsApi(content, data);
@@ -173,6 +170,20 @@ function methodsTable(data, m) {
         o.push(`**Since:** ${since}`);
         o.push(``);
     }
+    const example = getTagText(m.tags, 'example');
+    if (example) {
+        o.push(`#### Example`);
+        o.push(``);
+        if (example.startsWith('```')) {
+            o.push(example);
+        }
+        else {
+            o.push('```ts');
+            o.push(example);
+            o.push('```');
+        }
+        o.push(``);
+    }
     o.push(`--------------------`);
     o.push(``);
     o.push(``);
@@ -190,36 +201,68 @@ function markdownConfig(data) {
 }
 function buildExamples(c) {
     const o = [];
+    // Build the configuration object for JSON
+    const configObj = {};
+    c.properties.forEach((p) => {
+        // 1. Find @example
+        const exampleTag = p.tags.find((t) => t.name === 'example');
+        let val = exampleTag === null || exampleTag === void 0 ? void 0 : exampleTag.text;
+        // 2. If no @example, look for a default (often in code or @default tag)
+        if (val === undefined) {
+            const defaultTag = p.tags.find((t) => t.name === 'default');
+            val = defaultTag === null || defaultTag === void 0 ? void 0 : defaultTag.text;
+        }
+        // 3. Parsing the value (raw handling for strings/numbers/booleans)
+        if (val !== undefined) {
+            val = val.trim();
+            // if it's 'true' or 'false', convert to boolean
+            if (val === 'true')
+                configObj[p.name] = true;
+            else if (val === 'false')
+                configObj[p.name] = false;
+            // If it's a number, convert to number
+            else if (!isNaN(Number(val)))
+                configObj[p.name] = Number(val);
+            // If it's a string with quotes, remove them to get it clean
+            else if ((val.startsWith("'") && val.endsWith("'")) || (val.startsWith('"') && val.endsWith('"'))) {
+                configObj[p.name] = val.slice(1, -1);
+            }
+            // Otherwise leave as string
+            else
+                configObj[p.name] = val;
+        }
+    });
+    const jsonOutput = JSON.stringify({
+        plugins: {
+            [c.name]: configObj
+        }
+    }, null, 2);
     o.push(`### Examples`);
     o.push(``);
     o.push(`In \`capacitor.config.json\`:`);
     o.push(``);
     o.push(`\`\`\`json`);
-    o.push(`{`);
-    o.push(`  "plugins": {`);
-    o.push(`    "${c.name}": {`);
-    c.properties.forEach((p, i) => {
-        var _a;
-        o.push(`      "${p.name}": ${(_a = p.tags.find((t) => t.name === 'example')) === null || _a === void 0 ? void 0 : _a.text}${i === c.properties.length - 1 ? '' : ','}`);
-    });
-    o.push(`    }`);
-    o.push(`  }`);
-    o.push(`}`);
+    o.push(jsonOutput);
     o.push(`\`\`\``);
     o.push(``);
+    // For the TypeScript part (capacitor.config.ts)
     o.push(`In \`capacitor.config.ts\`:`);
     o.push(``);
     o.push(`\`\`\`ts`);
-    o.push(`/// <reference types="${process.env.npm_package_name}" />`);
+    // Fallback safe if npm_package_name doesn't exist
+    const pkgName = process.env.npm_package_name || 'package-name';
+    o.push(`/// <reference types="${pkgName}" />`);
     o.push(``);
     o.push(`import { CapacitorConfig } from '@capacitor/cli';`);
     o.push(``);
     o.push(`const config: CapacitorConfig = {`);
     o.push(`  plugins: {`);
     o.push(`    ${c.name}: {`);
-    c.properties.forEach((p) => {
-        var _a;
-        o.push(`      ${p.name}: ${(_a = p.tags.find((t) => t.name === 'example')) === null || _a === void 0 ? void 0 : _a.text},`);
+    // here we iterate to create the TS object (which accepts keys without quotes if valid)
+    Object.entries(configObj).forEach(([key, val]) => {
+        // Format the value for TS (strings need quotes)
+        const tsValue = typeof val === 'string' ? `'${val}'` : val;
+        o.push(`      ${key}: ${tsValue},`);
     });
     o.push(`    },`);
     o.push(`  },`);
@@ -363,7 +406,7 @@ async function outputJson(jsonFilePath, data) {
         throw new Error(`Missing data`);
     }
     const content = JSON.stringify(data, null, 2);
-    await mkdir(path_1.default.dirname(jsonFilePath), { recursive: true });
-    await writeFile(jsonFilePath, content);
+    await promises_1.mkdir(path_1.default.dirname(jsonFilePath), { recursive: true });
+    await promises_1.writeFile(jsonFilePath, content);
 }
 exports.outputJson = outputJson;
diff --git a/dist/parse.js b/dist/parse.js
index 8e863fbea8a18f9abdf54487032d43e20e318a81..cc0575343960b250359fc25cc6f308a4730ba268 100644
--- a/dist/parse.js
+++ b/dist/parse.js
@@ -17,7 +17,20 @@ const formatting_1 = require("./formatting");
 function parse(opts) {
     const tsProgram = transpile_1.getTsProgram(opts);
     const typeChecker = tsProgram.getTypeChecker();
-    const tsSourceFiles = tsProgram.getSourceFiles();
+    const tsSourceFiles = tsProgram.getSourceFiles().filter((sourceFile) => {
+        const fileName = sourceFile.fileName;
+        // Filter out TypeScript lib files (lib.dom.d.ts, lib.es2017.d.ts, etc.)
+        if (fileName.includes('/typescript/lib/lib.') || fileName.includes('\\typescript\\lib\\lib.')) {
+            return false;
+        }
+        // Filter out node_modules except @capacitor packages
+        if ((fileName.includes('/node_modules/') || fileName.includes('\\node_modules\\')) &&
+            !fileName.includes('/@capacitor/') &&
+            !fileName.includes('\\@capacitor\\')) {
+            return false;
+        }
+        return true;
+    });
     const interfaces = [];
     const enums = [];
     const typeAliases = [];
@@ -27,6 +40,20 @@ function parse(opts) {
     });
     return (api) => {
         const apiInterface = interfaces.find((i) => i.name === api) || null;
+        if (apiInterface) {
+            const configName = `${apiInterface.name}Config`;
+            const configIndex = interfaces.findIndex((i) => i.name === configName);
+            if (configIndex > -1) {
+                // found a config interface by convention
+                const [configInterface] = interfaces.splice(configIndex, 1);
+                pluginConfigs.push({
+                    name: configInterface.name,
+                    slug: configInterface.slug,
+                    docs: configInterface.docs,
+                    properties: configInterface.properties,
+                });
+            }
+        }
         const data = {
             api: apiInterface,
             interfaces: [],
@@ -78,8 +105,12 @@ function parseSourceFile(tsSourceFile, typeChecker, interfaces, typeAliases, enu
     const typeAliasDeclarations = statements.filter(typescript_1.default.isTypeAliasDeclaration);
     const enumDeclarations = statements.filter(typescript_1.default.isEnumDeclaration);
     const moduleDeclarations = statements.filter(typescript_1.default.isModuleDeclaration);
+    const processed = new Set();
     interfaceDeclarations.forEach((interfaceDeclaration) => {
-        interfaces.push(getInterface(typeChecker, interfaceDeclaration));
+        const parsedInterface = getInterface(typeChecker, interfaceDeclaration, processed);
+        if (parsedInterface) {
+            interfaces.push(parsedInterface);
+        }
     });
     enumDeclarations.forEach((enumDeclaration) => {
         enums.push(getEnum(typeChecker, enumDeclaration));
@@ -93,24 +124,36 @@ function parseSourceFile(tsSourceFile, typeChecker, interfaces, typeAliases, enu
         getPluginsConfig(typeChecker, moduleDeclaration, pluginConfigs);
     });
 }
-function getInterface(typeChecker, node) {
+function getInterface(typeChecker, node, processed = new Set()) {
     const interfaceName = node.name.text;
-    const methods = node.members.filter(typescript_1.default.isMethodSignature).reduce((methods, methodSignature) => {
-        const m = getInterfaceMethod(typeChecker, methodSignature);
-        if (m) {
-            methods.push(m);
-        }
-        return methods;
-    }, []);
-    const properties = node.members.filter(typescript_1.default.isPropertySignature).reduce((properties, properytSignature) => {
-        const p = getInterfaceProperty(typeChecker, properytSignature);
-        if (p) {
-            properties.push(p);
-        }
-        return properties;
-    }, []);
+    if (processed.has(interfaceName)) {
+        return null;
+    }
+    processed.add(interfaceName);
+    const methods = [];
+    const properties = [];
     const symbol = typeChecker.getSymbolAtLocation(node.name);
     const docs = symbol ? serializeSymbol(typeChecker, symbol) : null;
+    if (node.heritageClauses) {
+        for (const clause of node.heritageClauses) {
+            if (clause.token === typescript_1.default.SyntaxKind.ExtendsKeyword) {
+                clause.types.forEach((heritageType) => {
+                    const extendedType = typeChecker.getTypeAtLocation(heritageType);
+                    resolveType(extendedType, methods, properties, typeChecker, processed);
+                });
+            }
+        }
+    }
+    node.members.filter(typescript_1.default.isMethodSignature).forEach((methodSignature) => {
+        const method = getInterfaceMethod(typeChecker, methodSignature);
+        if (method)
+            methods.push(method);
+    });
+    node.members.filter(typescript_1.default.isPropertySignature).forEach((propertySignature) => {
+        const property = getInterfaceProperty(typeChecker, propertySignature);
+        if (property)
+            properties.push(property);
+    });
     const i = {
         name: interfaceName,
         slug: slugify(interfaceName),
@@ -257,21 +300,31 @@ function getPluginsConfig(typeChecker, moduleDeclaration, pluginConfigs) {
     pluginConfigInterfaces.forEach((pluginConfigInterface) => {
         pluginConfigInterface.members
             .filter(typescript_1.default.isPropertySignature)
-            .filter((p) => (p === null || p === void 0 ? void 0 : p.type) && (p === null || p === void 0 ? void 0 : p.type).members)
-            .forEach((properytSignature) => {
-            const typeLiteral = properytSignature.type;
-            const nm = properytSignature.name.getText();
-            const symbol = typeChecker.getSymbolAtLocation(properytSignature.name);
-            const docs = symbol ? serializeSymbol(typeChecker, symbol) : null;
+            .forEach(propertySignature => {
+            if (!propertySignature.type) {
+                return;
+            }
+            const nm = propertySignature.name.getText();
+            const docsSymbol = typeChecker.getSymbolAtLocation(propertySignature.name);
+            const docs = docsSymbol ? serializeSymbol(typeChecker, docsSymbol) : null;
+            let properties = [];
+            const type = typeChecker.getTypeFromTypeNode(propertySignature.type);
+            const props = typeChecker.getPropertiesOfType(type);
+            properties = props.map(prop => {
+                var _a;
+                const propDeclaration = (_a = prop.getDeclarations()) === null || _a === void 0 ? void 0 : _a[0];
+                if (!propDeclaration) {
+                    return null;
+                }
+                if (typescript_1.default.isPropertySignature(propDeclaration) || typescript_1.default.isPropertyDeclaration(propDeclaration)) {
+                    return getInterfaceProperty(typeChecker, propDeclaration);
+                }
+                return null;
+            }).filter((p) => p !== null);
             const i = {
                 name: nm,
                 slug: slugify(nm),
-                properties: typeLiteral.members
-                    .filter(typescript_1.default.isPropertySignature)
-                    .map((propertySignature) => {
-                    return getInterfaceProperty(typeChecker, propertySignature);
-                })
-                    .filter((p) => p != null),
+                properties: properties,
                 docs: (docs === null || docs === void 0 ? void 0 : docs.docs) || '',
             };
             if (i.properties.length > 0) {
@@ -332,6 +385,32 @@ function getEntityName(entity) {
         return getEntityName(entity.left);
     }
 }
+function resolveType(type, methods, properties, typeChecker, processed) {
+    const symbol = type.getSymbol();
+    if (symbol) {
+        const declarations = symbol.getDeclarations();
+        if (declarations) {
+            declarations.forEach((decl) => {
+                if (typescript_1.default.isInterfaceDeclaration(decl)) {
+                    const extendedInterface = getInterface(typeChecker, decl, processed);
+                    if (extendedInterface) {
+                        extendedInterface.methods.forEach((m) => {
+                            if (!methods.some((method) => method.name === m.name))
+                                methods.push(m);
+                        });
+                        extendedInterface.properties.forEach((p) => {
+                            if (!properties.some((prop) => prop.name === p.name))
+                                properties.push(p);
+                        });
+                    }
+                }
+            });
+        }
+    }
+    if (type.isIntersection()) {
+        type.types.forEach((subType) => resolveType(subType, methods, properties, typeChecker, processed));
+    }
+}
 function slugify(id) {
     const s = new github_slugger_1.default();
     return s.slug(id);
diff --git a/dist/transpile.js b/dist/transpile.js
index 8c013c07e9561e864a5ac6e36d794fd5054a94f4..c52706dd32543dfa46830f3a520ae263f7c52420 100644
--- a/dist/transpile.js
+++ b/dist/transpile.js
@@ -17,10 +17,13 @@ function getTsProgram(opts) {
                 typescript_1.default.flattenDiagnosticMessageText(configResult.error.messageText, '\n'));
         }
         const tsconfigDir = path_1.default.dirname(opts.tsconfigPath);
-        rootNames = configResult.config.files.map((f) => {
-            return path_1.default.join(tsconfigDir, f);
-        });
-        options = configResult.config.compilerOptions;
+        const parsedCommandLine = typescript_1.default.parseJsonConfigFileContent(configResult.config, typescript_1.default.sys, tsconfigDir, {}, opts.tsconfigPath);
+        if (parsedCommandLine.errors.length > 0) {
+            throw new Error(`Error parsing tsconfig file: "${opts.tsconfigPath}". ` +
+                typescript_1.default.flattenDiagnosticMessageText(parsedCommandLine.errors[0].messageText, '\n'));
+        }
+        rootNames = parsedCommandLine.fileNames;
+        options = parsedCommandLine.options;
     }
     else if (Array.isArray(opts.inputFiles) && opts.inputFiles.length > 0) {
         opts.inputFiles.forEach((i) => {
@@ -54,7 +57,8 @@ function getTsProgram(opts) {
     options.sourceMap = false;
     options.jsx = typescript_1.default.JsxEmit.React;
     options.module = typescript_1.default.ModuleKind.ESNext;
-    options.target = typescript_1.default.ScriptTarget.Latest;
+    options.target = typescript_1.default.ScriptTarget.ES2015;
+    options.lib = ['lib.es2015.d.ts', 'lib.dom.d.ts'];
     options.moduleResolution = typescript_1.default.ModuleResolutionKind.NodeJs;
     return typescript_1.default.createProgram({
         rootNames,
